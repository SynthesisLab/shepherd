# Shepherd

`Shepherd` is a Rust implementation of an algorithm solving the `random population control problem`,
presented in https://arxiv.org/abs/2411.15181 .

Starting from a non-deterministic finite automaton (nfa),
the algorithm performs a fixpoint computation of the 
maximal winning strategy for the random population control problem.
The strategy is finitely represented as a symbolic set of pairs of letters and configurations,
whose finite coordinates are below `|Q|`, where `Q` is the set of states of the nfa,
and other coordinates are Ï‰ (see Algorithm 1 in the paper for further details).

The fixpoint computation makes use of a subprocedure: an algorithm solving the so-called `path problem`.
Given a symbolic arena and a (finite) set of abstract configurations F in the arena,
this problem asks whether, from every finite configuration of the arena,
there exists a path within the arena that reaches a configuration in (the ideal generated by) F.
This is solved by computing a semigroup called the symbolic flow semigroup (see Theorem 26 in the paper for further details).

## Quick start
Install rust and cargo from https://www.rust-lang.org/tools/install

In the root folder launch

```cargo run -- examples/example1.tikz```

That will load an automaton from the file ```examples/example1.tikz```,
compute the maximal winning strategy for the random population control problem,
displays the answer in the terminal, including a winning strategy for positive instances.

For dot files 

```cargo run -- -i dot examples/bottleneck-1-ab.dot```

Check the file ```examples.pdf``` at the root  which gives an overview of all available examples.

## Input

Two kind of input files can be processed by `shepherd`.

### Tikz files (as produced by finsm.io)

- Create an automaton using https://finsm.io
- Copy paste the export (in Tikz format) in some local file and give it as input to shepherd.

### DOT files

You can give the input NFA in [graphviz DOT](https://graphviz.org/docs/layouts/dot/) format 
by setting the input-format as "dot" and give a path to a dot-file as input file:

```cargo run -- -i dot -f examples/bottleneck-1-ab.dot```

The input graphs are interpret as NFA using the following convention.

- All nodes except for one special node with id "init" are states of the NFA;
- Initial states are those which have an unlabeled edge from "init" into it;
- Accepting states are those with attribute "shape:doublecircle";
- Every edge with "label" attribute results in a transition over the value of that label

See `examples/bottleneck-1-ab.dot` for a dot-representation equivalent to the simple bottleneck in `examples/bottleneck-1-ab.tikz`.

## Output

Each computation produces and prints whether the given autonmaton is controllable or not.
For positive instances, it will also give a representation of the winning strategy.
You can optionally select which format this is given via the `-t` argument (either "tex" or "plain", defaults to "tex"),
and give the path to where the solution is written via the `-o` argument (defaults to stdout).

For a pretty latex report use

```
cargo run -- -f examples/example1.tikz -o report.tex && pdflatex report.tex
```

The states of the NFA can be automatically reordered in order to make the generated reports more readable.
Either topologically
```cargo run -- -s topological -i dot examples/bottleneck-2-staged.dot```
or alphabetically
```cargo run -- -s alphabetical -i dot examples/bottleneck-2-staged.dot```

Run 

```cargo run -- -help```

for all details.

## Perfs

```cargo build --release```
```./target/release/shepherd -s topological -i dot examples/bottleneck-2-staged.dot```


